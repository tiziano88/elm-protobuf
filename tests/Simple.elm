module Simple exposing (..)

-- DO NOT EDIT
-- AUTOGENERATED BY THE ELM PROTOCOL BUFFER COMPILER
-- https://github.com/tiziano88/elm-protobuf
-- source file: simple.proto

import Protobuf exposing (..)

import Json.Decode as JD
import Json.Encode as JE
import Dir.Other_dir exposing (..)
import Other exposing (..)


type Colour
    = ColourUnspecified -- 0
    | Red -- 1
    | Green -- 2
    | Blue -- 3


colourDecoder : JD.Decoder Colour
colourDecoder =
    let
        lookup s =
            case s of
                "COLOUR_UNSPECIFIED" ->
                    ColourUnspecified

                "RED" ->
                    Red

                "GREEN" ->
                    Green

                "BLUE" ->
                    Blue

                _ ->
                    ColourUnspecified
    in
        JD.map lookup JD.string


colourDefault : Colour
colourDefault = ColourUnspecified


colourEncoder : Colour -> JE.Value
colourEncoder v =
    let
        lookup s =
            case s of
                ColourUnspecified ->
                    "COLOUR_UNSPECIFIED"

                Red ->
                    "RED"

                Green ->
                    "GREEN"

                Blue ->
                    "BLUE"

    in
        JE.string <| lookup v


type alias Empty =
    {
    }
type EmptyMessage = EmptyMessage Empty


emptyDecoder : JD.Decoder Empty
emptyDecoder =
    JD.lazy <| \_ -> decode Empty


emptyEncoder : Empty -> JE.Value
emptyEncoder v =
    JE.object <| List.filterMap identity <|
        [
        ]


type alias Simple =
    { int32Field : Int -- 1
    }
type SimpleMessage = SimpleMessage Simple


simpleDecoder : JD.Decoder Simple
simpleDecoder =
    JD.lazy <| \_ -> decode Simple
        |> required "int32Field" intDecoder 0


simpleEncoder : Simple -> JE.Value
simpleEncoder v =
    JE.object <| List.filterMap identity <|
        [ (requiredFieldEncoder "int32Field" JE.int 0 v.int32Field)
        ]


type alias Foo =
    { s : Maybe SimpleMessage -- 1
    , ss : List SimpleMessage -- 2
    , colour : Colour -- 3
    , colours : List Colour -- 4
    , singleIntField : Int -- 5
    , repeatedIntField : List Int -- 6
    , bytesField : Bytes -- 9
    , stringValueField : Maybe String -- 10
    , otherField : Maybe OtherMessage -- 11
    , otherDirField : Maybe OtherDirMessage -- 12
    , timestampField : Maybe Timestamp -- 13
    , oo : Oo
    }


type Oo
    = OoUnspecified
    | Oo1 Int
    | Oo2 Bool


ooDecoder : JD.Decoder Oo
ooDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map Oo1 (JD.field "oo1" intDecoder)
        , JD.map Oo2 (JD.field "oo2" JD.bool)
        , JD.succeed OoUnspecified
        ]


ooEncoder : Oo -> Maybe ( String, JE.Value )
ooEncoder v =
    case v of
        OoUnspecified ->
            Nothing
        Oo1 x ->
            Just ( "oo1", JE.int x )
        Oo2 x ->
            Just ( "oo2", JE.bool x )
type FooMessage = FooMessage Foo


fooDecoder : JD.Decoder Foo
fooDecoder =
    JD.lazy <| \_ -> decode Foo
        |> optional "s" (JD.map SimpleMessage simpleDecoder)
        |> repeated "ss" (JD.map SimpleMessage simpleDecoder)
        |> required "colour" colourDecoder colourDefault
        |> repeated "colours" colourDecoder
        |> required "singleIntField" intDecoder 0
        |> repeated "repeatedIntField" intDecoder
        |> required "bytesField" bytesFieldDecoder []
        |> optional "stringValueField" stringValueDecoder
        |> optional "otherField" (JD.map OtherMessage otherDecoder)
        |> optional "otherDirField" (JD.map OtherDirMessage otherDirDecoder)
        |> optional "timestampField" timestampDecoder
        |> field ooDecoder


fooEncoder : Foo -> JE.Value
fooEncoder v =
    JE.object <| List.filterMap identity <|
        [ (optionalEncoder "s" (\(SimpleMessage f) -> simpleEncoder f) v.s)
        , (repeatedFieldEncoder "ss" (\(SimpleMessage f) -> simpleEncoder f) v.ss)
        , (requiredFieldEncoder "colour" colourEncoder colourDefault v.colour)
        , (repeatedFieldEncoder "colours" colourEncoder v.colours)
        , (requiredFieldEncoder "singleIntField" JE.int 0 v.singleIntField)
        , (repeatedFieldEncoder "repeatedIntField" JE.int v.repeatedIntField)
        , (requiredFieldEncoder "bytesField" bytesFieldEncoder [] v.bytesField)
        , (optionalEncoder "stringValueField" stringValueEncoder v.stringValueField)
        , (optionalEncoder "otherField" (\(OtherMessage f) -> otherEncoder f) v.otherField)
        , (optionalEncoder "otherDirField" (\(OtherDirMessage f) -> otherDirEncoder f) v.otherDirField)
        , (optionalEncoder "timestampField" timestampEncoder v.timestampField)
        , (ooEncoder v.oo)
        ]
