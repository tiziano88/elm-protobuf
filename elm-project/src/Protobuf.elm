module Protobuf exposing
    ( decode, required, optional, repeated, field
    , withDefault, intDecoder, fromResult
    , requiredFieldEncoder, optionalEncoder, repeatedFieldEncoder, numericStringEncoder, mapEntriesFieldEncoder, mapEntries
    , Bytes, bytesFieldDecoder, bytesFieldEncoder
    , Timestamp, timestampDecoder, timestampEncoder
    , intValueDecoder, intValueEncoder
    , stringValueDecoder, stringValueEncoder
    , boolValueDecoder, boolValueEncoder
    , bytesValueDecoder, bytesValueEncoder
    , floatValueDecoder, floatValueEncoder
    )

{-| Runtime library for Google Protocol Buffers.

This is mostly useless on its own, it is meant to support the code generated by the [Elm Protocol
Buffer compiler](https://github.com/tiziano88/elm-protobuf).


# Decoder Helpers

@docs decode, required, optional, repeated, field

@docs withDefault, intDecoder, fromResult


# Encoder Helpers

@docs requiredFieldEncoder, optionalEncoder, repeatedFieldEncoder, numericStringEncoder


# Bytes

@docs Bytes, bytesFieldDecoder, bytesFieldEncoder


# Well Known Types

@docs Timestamp, timestampDecoder, timestampEncoder

@docs intValueDecoder, intValueEncoder

@docs stringValueDecoder, stringValueEncoder

@docs boolValueDecoder, boolValueEncoder

@docs bytesValueDecoder, bytesValueEncoder

@docs floatValueDecoder, floatValueEncoder

-}

import ISO8601
import Json.Decode as JD
import Json.Encode as JE
import Time
import Dict


{-| Decodes a message.
-}
decode : a -> JD.Decoder a
decode =
    JD.succeed


{-| Decodes a required field.
-}
required : String -> JD.Decoder a -> a -> JD.Decoder (a -> b) -> JD.Decoder b
required name decoder default d =
    field (withDefault default <| JD.field name decoder) d


{-| Decodes an optional field.
-}
optional : String -> JD.Decoder a -> JD.Decoder (Maybe a -> b) -> JD.Decoder b
optional name decoder d =
    field (JD.maybe <| JD.field name decoder) d


{-| Decodes a repeated field.
-}
repeated : String -> JD.Decoder a -> JD.Decoder (List a -> b) -> JD.Decoder b
repeated name decoder d =
    field (withDefault [] <| JD.field name <| JD.list decoder) d

{-| Decodes a Dict.
-}
mapEntries : String -> JD.Decoder a -> JD.Decoder (Dict.Dict String a -> b) -> JD.Decoder b
mapEntries name valueDecoder d =
    field (withDefault Dict.empty <| JD.field name <| JD.dict valueDecoder) d


{-| Decodes a field.
-}
field : JD.Decoder a -> JD.Decoder (a -> b) -> JD.Decoder b
field =
    JD.map2 (|>)


{-| Provides a default value for a field.
-}
withDefault : a -> JD.Decoder a -> JD.Decoder a
withDefault default decoder =
    JD.oneOf
        [ decoder
        , JD.succeed default
        ]


{-| Encodes an optional field.
-}
optionalEncoder : String -> (a -> JE.Value) -> Maybe a -> Maybe ( String, JE.Value )
optionalEncoder name encoder v =
    Maybe.map (\x -> ( name, encoder x )) v



{-| Encodes a required field.
-}
requiredFieldEncoder : String -> (a -> JE.Value) -> a -> a -> Maybe ( String, JE.Value )
requiredFieldEncoder name encoder default v =
    if v == default then
        Nothing

    else
        Just ( name, encoder v )


{-| Encodes a repeated field.
-}
repeatedFieldEncoder : String -> (a -> JE.Value) -> List a -> Maybe ( String, JE.Value )
repeatedFieldEncoder name encoder v =
    case v of
        [] ->
            Nothing

        _ ->
            Just ( name, JE.list encoder v )

{-| Encodes dictionary field.
-}
mapEntriesFieldEncoder : String -> (a -> JE.Value) -> Dict.Dict String a -> Maybe ( String, JE.Value )
mapEntriesFieldEncoder name valueEncoder v =
    if Dict.isEmpty v then
        Nothing
    else
        let
            items = Dict.toList v
            encodedItems = List.map (\(key, val) -> (key, valueEncoder val)) items
        in
            Just ( name, JE.object encodedItems)


{-| Bytes field.
-}
type alias Bytes =
    List Int


{-| Decodes a bytes field.
TODO: Implement.
-}
bytesFieldDecoder : JD.Decoder Bytes
bytesFieldDecoder =
    JD.succeed []


{-| Encodes a bytes field.
TODO: Implement.
-}
bytesFieldEncoder : Bytes -> JE.Value
bytesFieldEncoder _ =
    JE.list JE.int []



-- Well Known Types.


{-| Timestamp.
-}
type alias Timestamp =
    Time.Posix


{-| Decodes a Timestamp.
-}
timestampDecoder : JD.Decoder Timestamp
timestampDecoder =
    JD.map ISO8601.fromString JD.string
        |> JD.andThen
            (\v ->
                case v of
                    Ok v1 ->
                        JD.succeed <| ISO8601.toPosix v1

                    Err e ->
                        JD.fail e
            )


{-| Encodes a Timestamp.
-}
timestampEncoder : Timestamp -> JE.Value
timestampEncoder v =
    JE.string <| ISO8601.toString <| ISO8601.fromPosix v


{-| Turns a Result in to a Decoder
Taken from <https://github.com/elm-community/json-extra/blob/2.7.0/src/Json/Decode/Extra.elm#L388>
-}
fromResult : Result String a -> JD.Decoder a
fromResult v =
    case v of
        Ok successValue ->
            JD.succeed successValue

        Err errorMessage ->
            JD.fail errorMessage


{-| Turns a Maybe in to a Decoder
-}
fromMaybe : String -> Maybe a -> JD.Decoder a
fromMaybe error maybe =
    case maybe of
        Just v1 ->
            JD.succeed v1

        Nothing ->
            JD.fail error


{-| Decodes an Int from either a string or numeric.
-}
intDecoder : JD.Decoder Int
intDecoder =
    JD.oneOf [ JD.int, JD.string |> JD.andThen (String.toInt >> fromMaybe "could not convert string to integer") ]


{-| Encodes an Int as a JSON string, for emitting to int64 proto3 fields
-}
numericStringEncoder : Int -> JE.Value
numericStringEncoder =
    String.fromInt >> JE.string


{-| Decodes an IntValue.
-}
intValueDecoder : JD.Decoder Int
intValueDecoder =
    intDecoder


{-| Encodes an IntValue.
-}
intValueEncoder : Int -> JE.Value
intValueEncoder =
    JE.int


{-| Decodes a StringValue.
-}
stringValueDecoder : JD.Decoder String
stringValueDecoder =
    JD.string


{-| Encodes a StringValue.
-}
stringValueEncoder : String -> JE.Value
stringValueEncoder =
    JE.string


{-| Encodes a BoolValue.
-}
boolValueDecoder : JD.Decoder Bool
boolValueDecoder =
    JD.bool


{-| Encodes a BoolValue.
-}
boolValueEncoder : Bool -> JE.Value
boolValueEncoder =
    JE.bool


{-| Decodes a BytesValue.
-}
bytesValueDecoder : JD.Decoder Bytes
bytesValueDecoder =
    bytesFieldDecoder


{-| Encodes a BytesValue.
-}
bytesValueEncoder : Bytes -> JE.Value
bytesValueEncoder =
    bytesFieldEncoder


{-| Decodes a FloatValue.
-}
floatValueDecoder : JD.Decoder Float
floatValueDecoder =
    JD.float


{-| Encodes a FloatValue.
-}
floatValueEncoder : Float -> JE.Value
floatValueEncoder =
    JE.float
